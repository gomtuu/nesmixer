#!/usr/bin/env python3

import struct
import sys

MODE = 'NES'

in_name = sys.argv[1]
IN = open(in_name, 'rb')
IN.seek(40)
frame_count = struct.unpack('<i', IN.read(4))[0] // 5

if in_name.endswith('.wav'):
    out_name = in_name[:-4] + '-mono.wav'
else:
    out_name = in_name + '.mono.wav'
OUT = open(out_name, 'wb')
OUT.write(b'RIFF')
OUT.write(struct.pack('<i', 36 + 0)) # ChunkSize
OUT.write(b'WAVE')
OUT.write(b'fmt ')
OUT.write(struct.pack('<i', 16)) # Subchunk1Size
if MODE == 'Mesen':
    OUT.write(struct.pack('<h', 1)) # AudioFormat (1 = PCM, 3 = float)
else:
    OUT.write(struct.pack('<h', 3)) # AudioFormat (1 = PCM, 3 = float)
OUT.write(struct.pack('<h', 1)) # NumChannels
OUT.write(struct.pack('<i', 1789773)) # SampleRate
OUT.write(struct.pack('<i', 1789773 * 1 * 4)) # ByteRate = SampleRate * NumChannels * BitsPerSample/8
OUT.write(struct.pack('<h', 1 * 4)) # BlockAlign = NumChannels * BitsPerSample/8
OUT.write(struct.pack('<h', 32)) # BitsPerSample
OUT.write(b'data')
OUT.write(struct.pack('<i', 0)) # Subchunk2Size

def mix_apu(pulse1, pulse2, triangle, noise, dmc):
    # https://wiki.nesdev.com/w/index.php/APU_Mixer
    pulse_out = 0
    pulse_sum = (pulse1 + pulse2)
    if pulse_sum:
        pulse_denom = 8128.0 / pulse_sum + 100.0
        if pulse_denom:
            pulse_out = 95.88 / pulse_denom
    tnd_out = 0
    tnd_sum = triangle / 8227.0 + noise / 12241.0 + dmc / 22638.0
    if tnd_sum:
        tnd_denom = 1.0 / tnd_sum + 100.0
        if tnd_denom:
            tnd_out = 159.79 / tnd_denom
    return pulse_out + tnd_out

def mix_mesen(pulse1, pulse2, triangle, noise, dmc):
    squareOutput = pulse1 + pulse2
    try:
        pulse_vol = (477600.0 / (8128.0 / squareOutput + 100.0))
    except ZeroDivisionError:
        pulse_vol = 0
    tndOutput = 3 * triangle + 2 * noise + dmc
    try:
        tnd_vol = (818350.0 / (24329.0 / tndOutput + 100.0))
    except ZeroDivisionError:
        tnd_vol = 0
    return int(pulse_vol + tnd_vol)

def find_triangle_discontinuities(IN):
    IN.seek(40)
    frame_count = struct.unpack('<i', IN.read(4))[0] // 5
    prev_triangle = None
    interpolation_ranges = []
    direction = 1
    for i in range(frame_count):
        channels = list(IN.read(5))
        triangle = channels[2]
        if i > 0:
            if direction and triangle != prev_triangle and triangle != prev_triangle + direction:
                print('Pop detected in triangle channel at sample', i)
                interpolation_ranges.append((last_change, (i, triangle)))
                direction = None
                # prev_triangle is now useless for determining direction, so start over
                prev_triangle = triangle
            if triangle - prev_triangle == 1:
                last_change = (i, triangle)
                direction = 1
            if triangle - prev_triangle == -1:
                last_change = (i, triangle)
                direction = -1
            if triangle == 15:
                direction = -1
            if triangle == 0:
                direction = 1
        else:
            last_change = (0, triangle)
        prev_triangle = triangle
        if i % 1789773 == 0:
            print('{:0.2f}%'.format(100 * i / frame_count))
    return interpolation_ranges

print('Scanning input file for pops in triangle channel...')
interpolation_ranges = find_triangle_discontinuities(IN)

print('Writing monaural output file...')
IN.seek(44)
range_end_i = 0
if interpolation_ranges:
    next_range_i = interpolation_ranges[0][0][0]
else:
    next_range_i = frame_count + 1
if MODE == 'Mesen':
    mix = mix_mesen
    out_format = '<i'
else:
    mix = mix_apu
    out_format = '<f'
j = 0
adjustment = 0
for i in range(frame_count):
    if i >= range_end_i:
        current_range = None
        adjustment = 0
        slope = 0
    if i >= next_range_i:
        current_range = interpolation_ranges.pop(0)
        range_begin = current_range[0]
        range_begin_i = range_begin[0]
        range_end = current_range[1]
        range_end_i = range_end[0]
        slope = (range_end[1] - range_begin[1]) / (range_end[0] - range_begin[0])
        if interpolation_ranges:
            next_range_i = interpolation_ranges[0][0][0]
        else:
            next_range_i = frame_count + 1
    channels = list(IN.read(5))
    if slope:
        # channels[2] is the triangle channel
        channels[2] = channels[2] + adjustment
        adjustment += slope
    sample = mix(*channels)
    OUT.write(struct.pack(out_format, sample))
    if j >= 1789773:
        print('{:0.2f}%'.format(100 * i / frame_count))
        eof = OUT.tell()
        OUT.seek(4)
        OUT.write(struct.pack('<i', 36 + i * 4))
        OUT.seek(40)
        OUT.write(struct.pack('<i', i * 4))
        OUT.seek(eof)
        j = 0
    j += 1

OUT.seek(4)
OUT.write(struct.pack('<i', 36 + frame_count * 4))
OUT.seek(40)
OUT.write(struct.pack('<i', frame_count * 4))
